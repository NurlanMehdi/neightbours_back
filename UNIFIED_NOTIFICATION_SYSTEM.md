# Унифицированная система уведомлений о сообщениях

## Обзор

Данная система обеспечивает отправку **только одного уведомления на пользователя на сообщение**, независимо от источника (WebSocket или HTTP endpoint). Система решает проблему дублирования push-уведомлений, которая возникала из-за множественных путей создания уведомлений.

## Архитектура решения

### 1. Унифицированный сервис уведомлений
- **Файл**: `src/modules/events/services/unified-message-notification.service.ts`
- **Назначение**: Единая точка входа для всех уведомлений о сообщениях
- **Функции**:
  - Дедупликация уведомлений на уровне messageId + userId
  - In-memory кеширование с TTL (1 час)
  - Подробное логирование для трассировки
  - Автоматическая очистка истекших записей

### 2. Рефакторинг существующих методов
- **WebSocket**: `EventsService.createMessage()` → использует `source: 'websocket'`
- **HTTP**: `EventsService.addMessage()` → использует `source: 'http'`
- Оба метода теперь используют `UnifiedMessageNotificationService.processMessageNotification()`

### 3. Механизм дедупликации
```typescript
interface INotificationDeduplicationEntry {
  messageId: number;
  userId: number;
  deviceToken?: string;
  timestamp: Date;
  source: string;
  requestId?: string;
}
```

## Как работает дедупликация

### Алгоритм
1. **Создание сообщения**: WebSocket или HTTP создает сообщение в БД
2. **Проверка кеша**: Система проверяет `msg_{messageId}_user_{userId}` в кеше
3. **Фильтрация получателей**: Исключает пользователей, которым уже отправлено уведомление
4. **Отправка уведомлений**: Отправляет только уникальным получателям
5. **Запись в кеш**: Сохраняет отправленные уведомления с TTL 1 час

### Пример логов

#### Успешная дедупликация
```log
[2025-09-12T15:30:45.123Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Обработка уведомления о сообщении 456 от пользователя 1 в событии 789 (источник: websocket)
[2025-09-12T15:30:45.125Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Отправка уведомлений 3 получателям: [2, 3, 4]
[2025-09-12T15:30:45.127Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Записано в кеш: пользователь 2, сообщение 456, устройство fcm_token_abc
[2025-09-12T15:30:45.128Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Записано в кеш: пользователь 3, сообщение 456, устройство fcm_token_def
[2025-09-12T15:30:45.129Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Записано в кеш: пользователь 4, сообщение 456, устройство нет токена
[2025-09-12T15:30:45.130Z] [UnifiedMessageNotificationService] [req_1694520645123_abc123def] Успешно отправлены уведомления о сообщении 456 для 3 получателей

// Попытка дублирования через HTTP
[2025-09-12T15:30:46.200Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Обработка уведомления о сообщении 456 от пользователя 1 в событии 789 (источник: http)
[2025-09-12T15:30:46.201Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Дубликат заблокирован для пользователя 2, сообщение 456. Предыдущая отправка: 2025-09-12T15:30:45.127Z (источник: websocket)
[2025-09-12T15:30:46.202Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Дубликат заблокирован для пользователя 3, сообщение 456. Предыдущая отправка: 2025-09-12T15:30:45.128Z (источник: websocket)
[2025-09-12T15:30:46.203Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Дубликат заблокирован для пользователя 4, сообщение 456. Предыдущая отправка: 2025-09-12T15:30:45.129Z (источник: websocket)
[2025-09-12T15:30:46.204Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Дедупликация: из 3 получателей, 0 уникальных
[2025-09-12T15:30:46.205Z] [UnifiedMessageNotificationService] [req_1694520646200_xyz789ghi] Все уведомления уже были отправлены для сообщения 456
```

## API для отладки

### Получить статистику кеша
```http
GET /debug/message-notifications/cache-stats
Authorization: Bearer <jwt-token>
```

**Ответ:**
```json
{
  "totalEntries": 150,
  "expiredEntries": 25,
  "activeEntries": 125,
  "oldestEntry": "2025-09-12T14:30:45.123Z",
  "newestEntry": "2025-09-12T15:30:45.123Z"
}
```

### Очистить кеш (для тестирования)
```http
DELETE /debug/message-notifications/cache
Authorization: Bearer <jwt-token>
```

**Ответ:**
```json
{
  "success": true,
  "message": "Кеш дедупликации очищен"
}
```

## Тестирование

### Автоматические тесты
Запустите тест-скрипт:
```typescript
import { runUnifiedNotificationTest } from './src/modules/events/test-scripts/test-unified-notifications';

// В вашем тестовом файле
await runUnifiedNotificationTest(eventsService, unifiedService);
```

### Ручное тестирование

1. **Отправьте сообщение через WebSocket**:
   ```javascript
   socket.emit('sendMessage', {
     eventId: 1,
     message: { text: 'Тестовое сообщение' }
   });
   ```

2. **Попробуйте отправить то же сообщение через HTTP**:
   ```http
   POST /events/messages
   Content-Type: application/json
   Authorization: Bearer <jwt-token>
   
   {
     "text": "Тестовое сообщение",
     "userId": 1,
     "eventId": 1
   }
   ```

3. **Проверьте логи** - должны увидеть сообщения о блокировке дубликатов

4. **Проверьте статистику кеша**:
   ```http
   GET /debug/message-notifications/cache-stats
   ```

## Преимущества системы

### ✅ Решенные проблемы
- **Дублирование уведомлений**: Каждый пользователь получает только одно уведомление на сообщение
- **Множественные пути**: WebSocket и HTTP используют единую систему
- **Отсутствие трассировки**: Подробные логи с request ID для отладки

### ✅ Качество кода
- **Единая ответственность**: Один сервис управляет всеми уведомлениями о сообщениях
- **Расширяемость**: Легко добавить новые источники (admin, bot, etc.)
- **Тестируемость**: Встроенные инструменты для тестирования и отладки
- **Производительность**: In-memory кеш с автоматической очисткой

### ✅ Операционные преимущества
- **Мониторинг**: API для проверки состояния системы
- **Отладка**: Детальные логи с трассировкой запросов
- **Безопасность**: TTL предотвращает бесконечный рост кеша
- **Надежность**: Graceful handling ошибок без прерывания работы

## Настройки

### Конфигурация TTL кеша
```typescript
// В UnifiedMessageNotificationService
private readonly CACHE_TTL_MS = 60 * 60 * 1000; // 1 час
```

### Интервал очистки кеша
```typescript
// Очистка каждые 30 минут
setInterval(() => this.cleanupExpiredCacheEntries(), 30 * 60 * 1000);
```

## Мониторинг в продакшене

### Ключевые метрики
- **Активные записи в кеше**: Должно расти при активности
- **Заблокированные дубликаты**: Показатель эффективности дедупликации
- **Ошибки уведомлений**: Мониторить через логи

### Алерты
- Если кеш растет слишком быстро (возможна утечка памяти)
- Если много ошибок при отправке уведомлений
- Если дедупликация не работает (нет блокировок дубликатов)

## Заключение

Унифицированная система уведомлений обеспечивает:
- **Один уведомление на пользователя на сообщение** ✅
- **Единый путь для всех источников** ✅ 
- **Полную трассируемость** ✅
- **Профессиональное качество кода** ✅

Система готова к продакшену и может быть легко расширена для других типов уведомлений.
